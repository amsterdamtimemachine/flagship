<!--
	ToggleGroup - A composable wrapper around Melt UI's toggle group

	This component handles the complexity of integrating Melt UI's toggle group with 
	custom rendering via Svelte 5 snippets. The architecture requires:

	1. DATA: Pass items array to initialize Melt UI state management
	2. RENDERING: Use children snippet to customize how each item renders
	3. CONSTRAINTS: Melt UI requires use:melt on HTML buttons (not components)
	
	The apparent "redundancy" of passing items AND rendering them via snippet is
	necessary because:
	- Melt UI needs the complete data array for state/accessibility management
	- We need rendering flexibility without losing toggle functionality
	- Can't use pure composition due to Svelte's use: directive limitations

	Usage:
	<ToggleGroup items={tags} selectedItems={selected}>
		{#snippet children(item, isSelected, isDisabled)}
			<Tag variant={isSelected ? 'selected' : 'default'}>{item}</Tag>
		{/snippet}
	</ToggleGroup>
-->
<script lang="ts">
	import { createToggleGroup, melt } from '@melt-ui/svelte';
	import { Check } from 'phosphor-svelte';
	import { mergeCss } from '$utils/utils';
	import type { Snippet } from 'svelte';
	import type { PhosphorIcon } from '@atm/shared/types';

	interface Props {
		items: string[];
		orientation?: 'horizontal' | 'vertical';
		type?: 'single' | 'multiple';
		selectedItems?: string[];
		disabledItems?: string[];
		onItemSelected?: (selected: string[] | string) => void;
		requireOneItemSelected?: boolean;
		class?: string;
		checkIcon?: PhosphorIcon;
		children: Snippet<[item: string, isSelected: boolean, isDisabled: boolean]>;
	}

	let {
		items,
		selectedItems = [],
		disabledItems = [],
		orientation = 'vertical',
		type = 'multiple',
		onItemSelected,
		requireOneItemSelected = false,
		class: className,
		checkIcon: CheckIcon = Check,
		children
	}: Props = $props();

	let sortedItems = $derived([...items].sort());

	const {
		elements: { root, item },
		states: { value }
	} = createToggleGroup({
		type,
		defaultValue: type === 'single' ? selectedItems[0] : selectedItems,
		orientation: orientation,
		onValueChange: ({ curr, next }) => {
			// If requireOneItemSelected is true, prevent empty selection
			if (requireOneItemSelected && (!next || (Array.isArray(next) && next.length === 0))) {
				// Reject the change - return current value to maintain selection
				return curr;
			}
			
			// Valid change - proceed normally
			if (onItemSelected && next !== undefined) {
				onItemSelected(next);
			}
			return next;
		}
	});

	function isSelected(itemValue: string): boolean {
		if (!$value) return false;
		if (type === 'single') {
			return $value === itemValue;
		} else {
			return Array.isArray($value) && $value.includes(itemValue);
		}
	}

	function isDisabled(itemValue: string): boolean {
		return disabledItems.includes(itemValue);
	}
</script>

<div
	use:melt={$root}
	class={mergeCss(
		"flex items-start data-[orientation='vertical']:flex-col data-[orientation='horizontal']:flex-row gap-1",
		className
	)}
	aria-label="Toggle selection"
	role={type === 'single' ? 'radiogroup' : 'group'}
>
	{#each sortedItems as itemValue (itemValue)}
		<button
			class="pb-1 last-child:pb-0 flex items-center gap-2 w-full text-left cursor-pointer  focus:outline-none  data-[disabled]:cursor-not-allowed data-[disabled]:opacity-50"
			use:melt={$item({ value: itemValue, disabled: isDisabled(itemValue) })}
			aria-label="Toggle {itemValue}"
			role={type === 'single' ? 'radio' : 'checkbox'}
			aria-checked={isSelected(itemValue)}
		>
			<!-- Checkbox (still generated by ToggleGroup) -->
			<span
				class="w-5 h-5 border-2 border-atm-gold rounded flex items-center justify-center bg-atm-sand-darkish"
				class:border-gray-500={isDisabled(itemValue)}
				aria-hidden="true"
			>
				{#if isSelected(itemValue)}
					<CheckIcon size={18} weight="bold" color="black" />
				{/if}
			</span>

			<!-- Composable content area -->
			{@render children(itemValue, isSelected(itemValue), isDisabled(itemValue))}
		</button>
	{/each}
</div>
